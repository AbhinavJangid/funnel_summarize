"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentHandler = void 0;
const util_1 = require("./util");
const axios_1 = require("axios");
const executeStepEndpoint = '/internal/ai-agents.events.execute-step';
const agentsCreateEndpoint = '/internal/ai-agents.create';
const agentsUpdateEndpoint = '/internal/ai-agents.update';
class AgentHandler {
    constructor(endpoint, token, goal, guidance, skills) {
        this.Goal = '';
        this.Guidance = '';
        this.Skills = [];
        this.token = '';
        this.endpoint = '';
        this.endpoint = endpoint;
        this.token = token;
        if (goal != undefined) {
            this.Goal = goal;
        }
        if (guidance != undefined) {
            this.Guidance = guidance;
        }
        if (skills != undefined) {
            this.Skills = skills;
        }
    }
    async InstallAgent() {
        console.log('installing agent');
        let resp;
        try {
            resp = await axios_1.default.post(this.endpoint + agentsCreateEndpoint, {
                'goal': this.Goal,
                'guidance': this.Guidance,
                'skills': {
                    'set': this.Skills.map((skill) => {
                        return {
                            name: skill.Name,
                            description: skill.Description,
                            input_schema: skill.InputSchema,
                        };
                    }),
                },
            }, {
                headers: {
                    Authorization: this.token,
                    'Content-Type': 'application/json',
                },
            });
        }
        catch (error) {
            console.error('Error installing agent: ', error);
            throw error;
        }
        let agent = resp.data.agent.id;
        let goal = resp.data.agent.goal;
        let guidance = resp.data.agent.guidance;
        console.log('Agent installed with id: %s goal: %s guidance: %s', agent, goal, guidance);
        return { agent, goal, guidance };
    }
    async UpdateAgent(agent, newGoal, newGuidance) {
        console.log('updating agent');
        let resp;
        try {
            resp = await axios_1.default.post(this.endpoint + agentsUpdateEndpoint, {
                'id': agent,
                'goal': newGoal,
                'guidance': newGuidance,
                'skills': {
                    'set': this.Skills.map((skill) => {
                        return {
                            name: skill.Name,
                            description: skill.Description,
                            input_schema: skill.InputSchema,
                        };
                    }),
                },
            }, {
                headers: {
                    Authorization: this.token,
                    'Content-Type': 'application/json',
                },
            });
        }
        catch (error) {
            console.error('Error updating agent: ', error);
            throw error;
        }
        let goal = resp.data.agent.goal;
        let guidance = resp.data.agent.guidance;
        console.log('Agent updated with id: %s goal: %s guidance: %s', agent, goal, guidance);
        return { agent, goal, guidance };
    }
    async Execute(input, agentId, sessionObjectId) {
        let { message, skillCalls } = await this.executeEvent(agentId, sessionObjectId, input);
        console.log('response for input %s is message: %s, skillCalls: %s', input, message, skillCalls);
        while (skillCalls.length > 0) {
            let results = [];
            for (let i = 0; i < skillCalls.length; i++) {
                let skillCall = skillCalls[i];
                let skill = this.Skills.find(skill => skill.Name === skillCall.name);
                if (skill) {
                    let result = await skill.Execute(skillCall);
                    results.push(new util_1.SkillOutput(skillCall.id, skillCall.name, result));
                    console.log('skillCall.id', skillCall.id, 'skillCall.name', skillCall.name, 'result', result);
                }
                else {
                    console.error(`Skill with name ${skillCall.name} not found`);
                    throw new Error(`Skill with name ${skillCall.name} not found`);
                }
            }
            const resp = await this.executeEvent(agentId, sessionObjectId, results);
            console.log('response for skillCalls %s is message: %s, skillCalls: %s', results, resp.message, resp.skillCalls);
            message = resp.message;
            skillCalls = resp.skillCalls;
        }
        return message;
    }
    async executeEvent(agent, session_object_id, inputEvent) {
        let event = {};
        if (typeof inputEvent === 'string') {
            event = {
                'type': 'input_message',
                'input_message': {
                    message: inputEvent,
                },
            };
        }
        else {
            event = {
                'type': 'skill_call_outputs',
                'skill_call_outputs': {
                    skill_call_outputs: inputEvent.map((skillOutput) => {
                        return {
                            skill_call_id: skillOutput.id,
                            skill_name: skillOutput.name,
                            output: { 'result': skillOutput.output },
                        };
                    }),
                },
            };
        }
        let resp;
        try {
            resp = await axios_1.default.post(this.endpoint + executeStepEndpoint, {
                'agent': agent,
                'session_object': session_object_id,
                'event': event,
            }, {
                headers: {
                    Authorization: this.token,
                    'Content-Type': 'application/json',
                },
            });
        }
        catch (error) {
            console.error('Error executing event: ', error);
            throw error;
        }
        let responseData = resp.data.step;
        let type = responseData.type;
        if (type == 'ai_message') {
            return {
                message: responseData.ai_message.message,
                skillCalls: [],
            };
        }
        const skillCalls = responseData.skill_call_messages.skill_call_messages.map((skill_call_message) => {
            return new util_1.SkillCall(skill_call_message.skill_call_id, skill_call_message.skill_name, skill_call_message.args);
        });
        return {
            message: 'need to execute skills',
            skillCalls,
        };
    }
}
exports.AgentHandler = AgentHandler;
