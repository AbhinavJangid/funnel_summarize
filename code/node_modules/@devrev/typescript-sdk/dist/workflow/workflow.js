"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Workflow = void 0;
const lru_cache_1 = require("lru-cache");
const client_1 = require("../client_setup/client");
const errors_1 = require("../errors");
const index_1 = require("../index");
const logger_1 = require("../logger");
/**
 * The Workflow class (BETA) provides methods to execute common workflows or sequences of API calls.
 * @example
 * ```typescript
 * const setup_options = { endpoint: 'https://api.devrev.ai', token: process.env.DEVREV_TOKEN };
 *
 * const workflow = new Workflow(setup_options);
 *
 * (async () => {
 *  const res = await workflow.createTicket('Sample title', 'user@example.com', 'Sample part');
 * })();
 *
 * ```
*/
class Workflow extends index_1.workflowSDK.Api {
    /**
     * The constructor for the Workflow class.
     * @param setupOptions The setup options for the SDK client.
     * @param logLevel The log level for the logger. Optional. Defaults to Logger.INFO. Other options are Logger.DEBUG, Logger.WARN, and Logger.ERROR
     * @param logger The logger for the Workflow class.
     * @example
     * ```typescript
     * const setup_options = { endpoint: 'https://api.devrev.ai', token: process.env.DEVREV_TOKEN };
     * const workflow = new Workflow(setup_options);
     * ```
     * @example
     * ```typescript
     * const setup_options = { endpoint: 'https://api.devrev.ai', token: process.env.DEVREV_TOKEN };
     * const workflow = new Workflow(setup_options, Logger.DEBUG);
     * ```
     */
    constructor(setupOptions, logLevel, logger) {
        const axiosConfig = (0, client_1.getAxiosRequestConfig)(setupOptions, 'beta');
        super(Object.assign({}, axiosConfig));
        // SDK setup
        this.api = index_1.client.setupWorkflows(setupOptions);
        // Logging setup
        if (typeof logger !== 'undefined') {
            this.logger = logger;
            if (typeof logLevel !== 'undefined') {
                this.logger.debug('The logLevel given to Workflow was ignored as you also gave logger');
            }
        }
        else {
            this.logger = (0, logger_1.getLogger)(Workflow.loggerName, logLevel !== null && logLevel !== void 0 ? logLevel : logger_1.LogLevel.INFO, logger);
        }
        this.customFragmentCache = new lru_cache_1.LRUCache({
            max: 1000, // number of items to prevent unbounded growth of the cache
        });
        this.logger.warn('Workflows are in beta and may change in the future');
    }
    /**
     * Creates a ticket workflow.
     * @param title The title of the ticket.
     * @param userEmail The email of the dev user associated with the ticket.
     * @param partName The name of the part associated with the ticket.
     * @returns The created ticket.
     */
    createTicket(title, userEmail, partName, additionalParams) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // TODO: Figure this out to automatically infer this
                this.logger.info('workflow(\'createTicket\') started');
                return yield this.createWork(title, userEmail, partName, index_1.workflowSDK.WorkType.Ticket, additionalParams);
            }
            catch (error) {
                this.handleError(error);
            }
            finally {
                this.logger.info('workflow(\'createTicket\') finished');
            }
        });
    }
    /**
     * Creates an issue workflow.
     * @param title The title of the issue.
     * @param userEmail The email of the dev user associated with the issue.
     * @param partName The name of the part associated with the issue.
     * @returns The created issue.
    */
    createIssue(title, userEmail, partName, additionalParams) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.logger.info('workflow(\'createIssue\') started');
                return yield this.createWork(title, userEmail, partName, index_1.workflowSDK.WorkType.Issue, additionalParams);
            }
            catch (error) {
                this.handleError(error);
            }
            finally {
                this.logger.info('workflow(\'createIssue\') finished');
            }
        });
    }
    /**
     * Creates a work workflow. Work is a generic term for tickets, issues, and tasks.
     * @param title The title of the work.
     * @param userEmail The email of the dev user associated with the work.
     * @param partName The name of the part associated with the work.
     * @returns The created work.
     */
    createWork(title, userEmail, partName, work_type, additionalParams) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const userListResponse = yield this.devUsersListPost({
                    email: [userEmail],
                });
                this.logger.debug('userList:', userListResponse.data.dev_users);
                let ownedBy = [];
                ownedBy.push(userListResponse.data.dev_users[0].id);
                const partListResponse = yield this.partsListPost({ name: [partName] });
                this.logger.debug('partList:', partListResponse.data.parts);
                // Add a warning if there are more than one parts with the same name
                if (partListResponse.data.parts.length > 1) {
                    this.logger.warn(`There are ${partListResponse.data.parts.length} parts with the name ${partName}. Using the first one.`);
                }
                const createWorkRequest = Object.assign({ type: work_type, applies_to_part: partListResponse.data.parts[0].id, owned_by: ownedBy, title: title }, additionalParams);
                const workResponse = yield this.worksCreate(createWorkRequest);
                this.logger.debug('work:', workResponse.data.work);
                return workResponse.data.work;
            }
            catch (error) {
                this.handleError(error, 'createWork');
            }
        });
    }
    /**
     * Looks up users by email.
     * @param emails The emails of the users to look up.
     * @param type The type of the users to look up. Takes either 'dev_user' or 'rev_user'. If not given, both dev and rev users will be looked up.
     * @returns The users that were looked up.
     * @example
     * ```typescript
     * // Look up dev users by email
     * const devUsers = await workflow.usersLookupByEmail(['test@example.com'], 'dev_user');
     *
     * // Look up rev users by email
     * const revUsers = await workflow.usersLookupByEmail(['test@example.com'], 'rev_user');
     *
     * // Look up both dev and rev users by email
     * const users = await workflow.usersLookupByEmail(['test@example.com']);
     * ```
     */
    usersLookupByEmail(emails, type) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.logger.info('workflow(\'usersLookupByEmail\') started');
                if (emails.length === 0) {
                    this.logger.warn('No emails given to usersLookupByEmail');
                    return [];
                }
                if (type === index_1.workflowSDK.UserType.DevUser) {
                    return yield this.devUsersLookupByEmail(emails);
                }
                if (type === index_1.workflowSDK.UserType.RevUser) {
                    return yield this.revUsersLookupByEmail(emails);
                }
                if (!type) {
                    // Return both dev and rev users
                    const devUsers = yield this.devUsersLookupByEmail(emails);
                    const revUsers = yield this.revUsersLookupByEmail(emails);
                    return devUsers.concat(revUsers);
                }
                this.logger.error(`Invalid user type: ${type}. Valid types are: ${index_1.workflowSDK.UserType.DevUser}, ${index_1.workflowSDK.UserType.RevUser}`);
            }
            catch (error) {
                this.handleError(error);
            }
            finally {
                this.logger.info('workflow(\'usersLookupByEmail\') finished');
            }
        });
    }
    /**
     * Looks up dev users by email.
     * @param emails The emails of the dev users to look up.
     * @returns The dev users that were found.
     * @example
     * const devUsers = await workflow.devUsersLookupByEmail(['test@example.com'], 'dev_user);
     * console.log(devUsers);
    */
    devUsersLookupByEmail(emails) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const devUsersListResponse = yield this.devUsersListPost({
                    email: emails,
                });
                return devUsersListResponse.data.dev_users;
            }
            catch (error) {
                this.handleError(error);
            }
        });
    }
    /**
     * Looks up rev users by email.
     * @param emails The emails of the rev users to look up.
     * @returns The rev users that were found.
     * @example
     * const revUsers = await workflow.revUsersLookupByEmail(['test@example.com'], 'rev_user);
     * console.log(revUsers);
     */
    revUsersLookupByEmail(emails) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const revUsersListResponse = yield this.revUsersListPost({
                    email: emails,
                });
                return revUsersListResponse.data.rev_users;
            }
            catch (error) {
                this.handleError(error);
            }
        });
    }
    /**
   * Fetches custom fragments for the given fragment IDs.
   * @param fragmentIDs - An array of fragment IDs to fetch.
   * @returns A Promise that resolves to an array of custom fragments. Preserves the order of the fragmentIDs array.
   */
    fetchCustomFragments(fragmentIDs) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Can we do batch requests for custom fragments?
            const uniqueFragmentIDs = [...new Set(fragmentIDs)];
            let uncachedFragmentIDs = [];
            // Map to store fragmentID -> fragment
            let fragmentMap = new Map();
            for (const fragmentID of uniqueFragmentIDs) {
                const cachedFragment = this.customFragmentCache.get(fragmentID);
                if (cachedFragment) {
                    // If the fragment is cached, add it to the map
                    fragmentMap.set(fragmentID, cachedFragment);
                }
                else {
                    // If the fragment is not cached, add it to the list of uncached fragments
                    uncachedFragmentIDs.push(fragmentID);
                }
            }
            // Fetch the uncached fragments sequentially
            // Note: Intentionally not using Promise.all() to avoid overloading the server
            const fetchedFragments = [];
            for (const id of uncachedFragmentIDs) {
                const response = yield this.customSchemaFragmentsGet({ id });
                const fragment = response.data.fragment;
                this.customFragmentCache.set(id, fragment);
                fragmentMap.set(id, fragment);
                fetchedFragments.push(fragment);
            }
            // Return the mapped fragments from the cache
            return fragmentIDs.map((id) => fragmentMap.get(id)); // I think this is safe
        });
    }
    /**
   * Adds custom fragments to objects that have custom_schema_fragments property.
   * @template T - The type of the objects with custom_schema_fragments property.
   * @param objects - An array of objects with custom_schema_fragments property.
   * @returns A Promise that resolves to an array of objects with custom_fragment property.
   */
    addCustomFragments(objects) {
        return __awaiter(this, void 0, void 0, function* () {
            // Extract all the custom fragment IDs from the objects
            const customFragmentIDs = objects.flatMap((object) => { var _a; return (_a = object.custom_schema_fragments) !== null && _a !== void 0 ? _a : []; });
            // Remove duplicates
            const uniqueCustomFragmentIDs = [...new Set(customFragmentIDs)];
            // Fetch the custom fragments
            const customFragments = yield this.fetchCustomFragments(uniqueCustomFragmentIDs);
            // Map fragmentID -> fragment
            const customFragmentsMap = new Map(); // Todo: Replace any with CustomSchemaFragment
            customFragments.forEach((fragment) => {
                customFragmentsMap.set(fragment.id, fragment);
            });
            // Add the custom fragments to the objects
            const objectsWithCustomFragments = objects.map((object) => {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                const custom_fragment = object.custom_schema_fragments
                    ? object.custom_schema_fragments.map((fragmentID) => customFragmentsMap.get(fragmentID))
                    : [];
                return Object.assign(Object.assign({}, object), { custom_fragment });
            });
            return objectsWithCustomFragments;
        });
    }
    /**
   * Processes 'list' or 'get' API response data and adds custom fragments to the objects, if applicable.
   * @template Q - The type of the query parameter. Ex: WorksGetRequest / worksListRequest
   * @template R - The type of the API response data. Ex: WorksGetResponse / WorksListResponse
   * @template T - The type of the objects with custom_schema_fragments property. Ex: Work
   * @param query - The query parameter for the API call.
   * @param apiMethod - The API method to be called. Ex: worksGet / worksList
   * @param keyName - The name of the key in the API response data where the objects are located.
   * @returns A Promise that resolves to the processed AxiosResponse with custom fragments added to the objects.
   */
    processWithCustomFragments(query, apiMethod, keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield apiMethod(query);
                if (!(keyName in res.data)) {
                    this.logger.error(`Expected ${keyName} in response data, but it was not found.`);
                    return res;
                }
                const data = Array.isArray(res.data[keyName]) ? res.data[keyName] : [res.data[keyName]];
                const objectsWithCustomFragments = yield this.addCustomFragments(data);
                res.data[keyName] = Array.isArray(res.data[keyName]) ? objectsWithCustomFragments : objectsWithCustomFragments[0];
                // Scope of the cache is limited to the current request to avoid stale data
                this.customFragmentCache.clear();
                return res;
            }
            catch (error) {
                // TODO: Add more specific error handling
                this.logger.error(`Error in processWithCustomFragments for ${keyName}:`, error);
                throw error;
            }
        });
    }
    /**
   * Fetches the works with custom fragments for the given query.
   * @param query - The query parameter for the worksGet API call.
   * @returns A Promise that resolves to the AxiosResponse with updated work containing custom fragments.
   */
    worksGetWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.worksGet, 'work');
        });
    }
    /**
   * Fetches the works list with custom fragments for the given query.
   * @param query - The query parameter for the worksList API call.
   * @returns A Promise that resolves to the AxiosResponse with updated works containing custom fragments.
   */
    worksListWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.worksList, 'works');
        });
    }
    /**
   * Fetches the account with custom fragments for the given query.
   * @param query - The query parameter for the accountsGet API call.
   * @returns A Promise that resolves to the AxiosResponse with updated account containing custom fragments.
   */
    accountsGetWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.accountsGet, 'account');
        });
    }
    /**
   * Fetches the accounts list with custom fragments for the given query.
   * @param query - The query parameter for the accountsList API call.
   * @returns A Promise that resolves to the AxiosResponse with updated accounts containing custom fragments.
   */
    accountsListWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.accountsList, 'accounts');
        });
    }
    /**
   * Fetches the rev_org with custom fragments for the given query.
   * @param query - The query parameter for the revOrgsGet API call.
   * @returns A Promise that resolves to the AxiosResponse with updated rev_org containing custom fragments.
   */
    revOrgsGetWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.revOrgsGet, 'rev_org');
        });
    }
    /**
   * Fetches the rev_org list with custom fragments for the given query.
   * @param query - The query parameter for the revOrgsList API call.
   * @returns A Promise that resolves to the AxiosResponse with updated rev_orgs containing custom fragments.
   */
    revOrgsListWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.revOrgsList, 'rev_orgs');
        });
    }
    /**
   * Fetches the rev_user with custom fragments for the given query.
   * @param query - The query parameter for the revUsersGet API call.
   * @returns A Promise that resolves to the AxiosResponse with updated rev_user containing custom fragments.
   */
    revUsersGetWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.revUsersGet, 'rev_user');
        });
    }
    /**
   * Fetches the rev_user list with custom fragments for the given query.
   * @param query - The query parameter for the revUsersList API call.
   * @returns A Promise that resolves to the AxiosResponse with updated rev_users containing custom fragments.
   */
    revUsersListWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.revUsersList, 'rev_users');
        });
    }
    /**
     * Fetches the part with custom fragments for the given query.
     * @param query - The query parameter for the partsGet API call.
     * @returns A Promise that resolves to the AxiosResponse with updated part containing custom fragments.
     */
    partsGetWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.partsGet, 'part');
        });
    }
    /**
     * Fetches the parts list with custom fragments for the given query.
     * @param query - The query parameter for the partsList API call.
     * @returns A Promise that resolves to the AxiosResponse with updated parts containing custom fragments.
    */
    partsListWithCustomFragments(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.processWithCustomFragments(query, this.partsList, 'parts');
        });
    }
    /**
     * Handles errors that occur during API requests.
     * @param error The error object.
     */
    handleError(error, workflow) {
        if (workflow) {
            this.logger.error(`workflow('${workflow}') encountered an error.`);
        }
        errors_1.WorkflowErrorHandler.handle(error);
    }
}
exports.Workflow = Workflow;
/**
 * The logger name for the Workflow class.
 */
Workflow.loggerName = 'workflow';
//# sourceMappingURL=workflow.js.map