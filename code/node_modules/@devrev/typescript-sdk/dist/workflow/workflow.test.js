"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
const logger_1 = require("../logger");
const test_helpers_1 = require("./test-helpers");
require('dotenv').config();
const setupOptions = { endpoint: (_a = process.env.ENDPOINT) !== null && _a !== void 0 ? _a : '', token: (_b = process.env.TOKEN) !== null && _b !== void 0 ? _b : '' };
// Mock implementation of Logger
class LoggerMock {
    constructor() {
        this.info = jest.fn();
        this.debug = jest.fn();
        this.error = jest.fn();
        this.warn = jest.fn();
        this.setLevel = jest.fn();
        this.getLevel = jest.fn();
        this.setName = jest.fn();
    }
}
describe('Workflow', () => {
    let logger;
    let workflow;
    let uniqueTestIdentifier;
    let currDevUser;
    let initPart;
    let initWork;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        logger = new LoggerMock();
        workflow = new index_1.Workflow(setupOptions, logger_1.LogLevel.INFO, logger);
        uniqueTestIdentifier = `workflow.test(${Date.now()})`;
        // Get the current Dev User
        currDevUser = (yield workflow.devUsersSelf()).data.dev_user;
        // Create a new part
        initPart = (yield workflow.partsCreate({
            name: uniqueTestIdentifier + ' Part',
            type: index_1.workflowSDK.PartType.Product,
            owned_by: [currDevUser.id],
        })).data.part;
        // Create a new work
        initWork = (yield workflow.worksCreate({
            title: uniqueTestIdentifier + ' Work',
            applies_to_part: initPart.id,
            type: index_1.workflowSDK.WorkType.Ticket,
            owned_by: [currDevUser.id],
        })).data.work;
    }));
    afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
        jest.clearAllMocks();
        // Delete the part
        const partDeleteRes = yield workflow.partsDelete({ id: initPart.id });
        expect(partDeleteRes.status).toBe(200);
        // Delete the work
        const workDeleteRes = yield workflow.worksDelete({ id: initWork.id });
        expect(workDeleteRes.status).toBe(200);
    }));
    describe('usersLookupByEmail', () => {
        test('should return dev_users for the given email lists', () => __awaiter(void 0, void 0, void 0, function* () {
            const wantUsers = yield (0, test_helpers_1.getDevUsers)();
            const emails = wantUsers.map((user) => user.email);
            const haveUsers = yield workflow.usersLookupByEmail(emails, 'dev_user');
            expect(haveUsers).toEqual(wantUsers);
        }), 50000);
        test('should return empty list if there exists no user corresponding to email list', () => __awaiter(void 0, void 0, void 0, function* () {
            const emails = ['imposter@example.com'];
            const wantUsers = [];
            const haveUsers = yield workflow.usersLookupByEmail(emails);
            expect(haveUsers).toEqual(wantUsers);
        }), 50000);
        test('should return rev_users for the given email lists', () => __awaiter(void 0, void 0, void 0, function* () {
            const revUsers = yield (0, test_helpers_1.getRevUsers)();
            const wantUsers = revUsers.filter((user) => typeof user.email !== 'undefined');
            const emails = wantUsers.map((user) => user.email);
            const haveUsers = yield workflow.usersLookupByEmail(emails, 'rev_user');
            expect(haveUsers).toEqual(wantUsers);
        }), 50000);
        test('should return both dev_users and rev_users for the given email lists', () => __awaiter(void 0, void 0, void 0, function* () {
            const wantDevUsers = yield (0, test_helpers_1.getDevUsers)();
            const wantRevUsers = yield (0, test_helpers_1.getRevUsers)();
            const wantDevUsersSimplified = wantDevUsers.map((user) => ({ email: user.email, id: user.id }));
            const wantRevUsersSimplified = wantRevUsers.map((user) => ({ email: user.email, id: user.id }));
            const wantUsersSimplified = [...wantDevUsersSimplified, ...wantRevUsersSimplified].filter((user) => typeof user.email !== 'undefined');
            const emails = wantUsersSimplified.map((user) => user.email);
            const haveUsers = yield workflow.usersLookupByEmail(emails);
            const haveUsersSimplified = haveUsers === null || haveUsers === void 0 ? void 0 : haveUsers.map((user) => ({ email: user.email, id: user.id }));
            expect(haveUsersSimplified).toEqual(wantUsersSimplified);
        }), 50000);
    });
    describe('createTicket', () => {
        test('should create a ticket with the given title, email and part_name', () => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const title = uniqueTestIdentifier + ' Ticket';
            const email = currDevUser.email; // DevUserSelf email is always defined
            const partName = initPart.name;
            const haveTicket = yield workflow.createTicket(title, email, partName);
            expect(haveTicket).not.toBeUndefined();
            if (haveTicket) {
                expect(haveTicket.title).toEqual(title);
                expect((_a = haveTicket.applies_to_part) === null || _a === void 0 ? void 0 : _a.name).toEqual(partName);
                expect(haveTicket.owned_by.length).toEqual(1);
                expect(haveTicket.owned_by[0].email).toEqual(email);
                // delete the created ticket
                const deleteRes = yield workflow.worksDelete({ id: haveTicket.id });
                expect(deleteRes.status).toBe(200);
            }
        }), 10000);
        test('should create a ticket with additional parameters', () => __awaiter(void 0, void 0, void 0, function* () {
            var _b;
            const title = uniqueTestIdentifier + ' Ticket';
            const email = currDevUser.email; // DevUserSelf email is always defined
            const partName = initPart.name;
            const additionalParameters = {
                body: uniqueTestIdentifier + ' Body',
                severity: index_1.workflowSDK.TicketSeverity.Low,
                stage: { name: 'in_development' },
            };
            const haveTicket = yield workflow.createTicket(title, email, partName, additionalParameters);
            expect(haveTicket).not.toBeUndefined();
            if (haveTicket) {
                expect(haveTicket.title).toEqual(title);
                expect((_b = haveTicket.applies_to_part) === null || _b === void 0 ? void 0 : _b.name).toEqual(partName);
                expect(haveTicket.owned_by.length).toEqual(1);
                expect(haveTicket.owned_by[0].email).toEqual(email);
                expect(haveTicket.body).toEqual(additionalParameters.body);
                expect(haveTicket.severity).toEqual(additionalParameters.severity);
                expect(haveTicket.stage).toEqual(additionalParameters.stage);
                // delete the created ticket
                const deleteRes = yield workflow.worksDelete({ id: haveTicket.id });
                expect(deleteRes.status).toBe(200);
            }
        }), 10000);
    });
    describe('createIssue', () => {
        test('should create an issue with the given title, email and part_name', () => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const title = uniqueTestIdentifier + ' Issue';
            const email = currDevUser.email; // DevUserSelf email is always defined
            const partName = initPart.name;
            const haveIssue = yield workflow.createIssue(title, email, partName);
            expect(haveIssue).not.toBeUndefined();
            if (haveIssue) {
                expect(haveIssue.title).toEqual(title);
                expect((_a = haveIssue.applies_to_part) === null || _a === void 0 ? void 0 : _a.name).toEqual(partName);
                expect(haveIssue.owned_by.length).toEqual(1);
                expect(haveIssue.owned_by[0].email).toEqual(email);
                // delete the created issue
                const deleteRes = yield workflow.worksDelete({ id: haveIssue.id });
                expect(deleteRes.status).toBe(200);
            }
        }), 10000);
        test('should create an issue with additional parameters', () => __awaiter(void 0, void 0, void 0, function* () {
            var _b;
            const title = uniqueTestIdentifier + ' Issue';
            const email = currDevUser.email; // DevUserSelf email is always defined
            const partName = initPart.name;
            const additionalParameters = {
                body: uniqueTestIdentifier + ' Body',
                priority: index_1.workflowSDK.IssuePriority.P3,
                stage: { name: 'in_development' },
            };
            const haveIssue = yield workflow.createIssue(title, email, partName, additionalParameters);
            expect(haveIssue).not.toBeUndefined();
            if (haveIssue) {
                expect(haveIssue.title).toEqual(title);
                expect((_b = haveIssue.applies_to_part) === null || _b === void 0 ? void 0 : _b.name).toEqual(partName);
                expect(haveIssue.owned_by.length).toEqual(1);
                expect(haveIssue.owned_by[0].email).toEqual(email);
                expect(haveIssue.body).toEqual(additionalParameters.body);
                expect(haveIssue.priority).toEqual(additionalParameters.priority);
                expect(haveIssue.stage).toEqual(additionalParameters.stage);
                // delete the created issue
                const deleteRes = yield workflow.worksDelete({ id: haveIssue.id });
                expect(deleteRes.status).toBe(200);
            }
        }), 10000);
    });
    describe('customization', () => {
        const fragmentIDs = [];
        const createField = (fieldType) => {
            const baseFieldProps = {
                name: `my_awesome_${fieldType}_field`,
                description: `my_awesome_${fieldType}_field_description`,
                field_type: fieldType,
                is_filterable: Math.random() >= 0.5,
                is_pii: Math.random() >= 0.5,
                is_required: false,
                ui: {
                    display_name: `My awesome ${fieldType} field`,
                },
            };
            const fieldSpecificProps = {
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.Array]: { base_type: index_1.workflowSDK.SchemaFieldDescriptorFieldType.Bool, default_value: [false] },
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.Bool]: { default_value: false },
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.Date]: { default_value: '2021-01-01' },
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.Double]: { default_value: 0.0 },
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.Enum]: { allowed_values: ['Value1', 'Value2'], default_value: 'Value1' },
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.Id]: {
                    default_value: initWork.id,
                    id_type: ['issue', 'ticket'],
                },
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.Int]: { default_value: 0 },
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.RichText]: { default_value: '<p>Rich Text</p>' },
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.Text]: { default_value: 'Text' },
                [index_1.workflowSDK.SchemaFieldDescriptorFieldType.Timestamp]: { default_value: '2021-01-01T00:00:00.000Z' },
            };
            return Object.assign(Object.assign({}, baseFieldProps), fieldSpecificProps[fieldType]);
        };
        const getFieldDescriptors = () => [
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.Array),
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.Bool),
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.Date),
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.Double),
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.Enum),
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.Id),
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.Int),
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.RichText),
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.Text),
            createField(index_1.workflowSDK.SchemaFieldDescriptorFieldType.Timestamp),
        ];
        let fragmentIDToSchemaMap;
        let accountID;
        // let revOrgID: string; 
        beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
            // App fragment
            try {
                // Create an account (Necessary for rev_org clean-ups)
                accountID = (yield workflow.accountsCreate({
                    display_name: uniqueTestIdentifier + ' Account',
                })).data.account.id;
                // Create a rev_org (Necessary for rev_users clean-ups)
                // TODO - Uncomment when rev_org fields are added to RevUser APIs in beta
                // revOrgID = (await workflow.revOrgsCreate({
                //   display_name: 'SDK Workflow Test Rev Org',
                //   account: accountID,
                // })).data.rev_org.id;
                fragmentIDToSchemaMap = new Map();
                const fields = getFieldDescriptors();
                const appFragment = yield workflow.customSchemaFragmentsSet({
                    app: 'my_awesome_app',
                    // app_fragment_name: 'my_awesome_app_fragment',
                    description: 'This is a test fragment',
                    type: index_1.workflowSDK.CustomSchemaFragmentsSetRequestType.AppFragment,
                    leaf_type: 'issue',
                    fields: fields,
                });
                fragmentIDs.push(appFragment.data.id);
                // Custom type fragment
                // Tenant fragment
                // Store the fragment ID to schema map
                const fetchPromises = fragmentIDs.map((fragmentID) => workflow.customSchemaFragmentsGet({ id: fragmentID }));
                const responses = yield Promise.all(fetchPromises);
                responses.forEach((res, index) => {
                    const fragmentID = fragmentIDs[index];
                    fragmentIDToSchemaMap.set(fragmentID, res.data.fragment);
                });
            }
            catch (e) {
                console.log('error', e);
                throw e;
            }
        }), 100000);
        afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
            /**
             * Deleting the account
             * Deleting an account automatically deletes all rev_orgs associated with it
             * Deleting a rev_org automatically deletes all rev_users associated with it
             */
            const accountDeleteRes = yield workflow.accountsDelete({ id: accountID });
            expect(accountDeleteRes.status).toBe(200);
            // TODO: All the fragments created in the beforeAll should be deleted
        }));
        const getCreateRequestParameters = (createMethod) => __awaiter(void 0, void 0, void 0, function* () {
            const WORK_TYPE = Math.random() >= 0.5 ? index_1.workflowSDK.WorkType.Ticket : index_1.workflowSDK.WorkType.Issue;
            const uniqueName = uniqueTestIdentifier + Math.random().toString(36).substring(7);
            switch (createMethod) {
                case workflow.worksCreate:
                    return {
                        applies_to_part: initPart.id,
                        owned_by: [currDevUser.id],
                        title: uniqueName,
                        type: WORK_TYPE,
                    };
                case workflow.accountsCreate:
                case workflow.revOrgsCreate:
                    return {
                        display_name: uniqueName,
                        // account: accountID, Todo: Uncomment when account fields are added to RevOrg APIs in beta
                    };
                case workflow.revUsersCreate:
                    return {
                        display_name: uniqueName,
                        // rev_org: revOrgID, // Todo: Uncomment when rev_org fields are added to RevUser APIs in beta
                    };
                case workflow.partsCreate:
                    return {
                        name: uniqueName,
                        owned_by: [currDevUser.id],
                        type: index_1.workflowSDK.PartType.Product,
                    };
                default:
                    throw new Error('Invalid create method');
            }
        });
        describe('list calls', () => {
            // TODO: Add tests for all the list calls with filters
            const runListCallTest = (createMethod, sdkCustomizationListMethod, deleteMethod, objectType, customKey) => __awaiter(void 0, void 0, void 0, function* () {
                const createRequestParams = yield getCreateRequestParameters(createMethod);
                const wantObject = (yield createMethod(Object.assign(Object.assign({}, createRequestParams), { [customKey]: fragmentIDs }))).data[`${objectType}`];
                expect(wantObject).toEqual(expect.objectContaining({ custom_schema_fragments: fragmentIDs }));
                // Calling the SDK method
                const objects = (yield sdkCustomizationListMethod({})).data[`${objectType}s`];
                expect(objects).not.toBeUndefined();
                const haveObject = objects.find((obj) => obj.id === wantObject.id);
                expect(haveObject).toEqual(expect.objectContaining({ custom_schema_fragments: fragmentIDs }));
                for (let i = 0; i < fragmentIDs.length; ++i) {
                    const fragmentID = fragmentIDs[i];
                    const wantFragment = fragmentIDToSchemaMap.get(fragmentID);
                    const haveFragment = haveObject === null || haveObject === void 0 ? void 0 : haveObject.custom_fragment[i]; // Preserves the order of the fragments
                    expect(haveFragment).toEqual(wantFragment);
                }
                // Cleanup
                if (deleteMethod) {
                    const deleteRes = yield deleteMethod({ id: wantObject.id });
                    expect(deleteRes.status).toBe(200);
                }
            });
            test('return custom_fragment for works.list', () => __awaiter(void 0, void 0, void 0, function* () {
                yield runListCallTest(workflow.worksCreate, workflow.worksListWithCustomFragments.bind(workflow), workflow.worksDelete, 'work', 'custom_schema_fragments');
            }), 100000);
            test('return custom_fragment for accounts.list', () => __awaiter(void 0, void 0, void 0, function* () {
                yield runListCallTest(workflow.accountsCreate, workflow.accountsListWithCustomFragments.bind(workflow), workflow.accountsDelete, 'account', 'schema_fragment_ids');
            }), 100000);
            // Clean-up is not supported. It will be supported when account fields are added to RevOrg APIs in beta.
            // Note: Uncomment the code adding account ID in revOrgs create request parameters.
            test('return custom_fragment for rev-orgs.list', () => __awaiter(void 0, void 0, void 0, function* () {
                yield runListCallTest(workflow.revOrgsCreate, workflow.revOrgsListWithCustomFragments.bind(workflow), null, // gets deleted when the account is deleted
                'rev_org', 'custom_schema_fragments');
            }), 100000);
            // Clean-up is not supported. It will be supported when rev_org fields are added to RevUser APIs in beta.
            // Note: Uncomment the code adding rev_org ID in revUsers create request parameters.
            test('return custom_fragment for rev-users.list', () => __awaiter(void 0, void 0, void 0, function* () {
                yield runListCallTest(workflow.revUsersCreate, workflow.revUsersListWithCustomFragments.bind(workflow), workflow.revUsersDelete, 'rev_user', 'custom_schema_fragments');
            }), 100000);
            // TODO: This test is not working because of absence of custom_schema_fragments in the request of parts.create API.
            // Update public-beta-devrev-sdk.ts to add custom_schema_fragments in the request of parts.create API.
            // test('return custom_fragment for parts.list', async () => {
            //   await runListCallTest(
            //     workflow.partsCreate,
            //     workflow.partsListWithCustomFragments.bind(workflow),
            //     workflow.partsDelete,
            //     'part',
            //     'custom_schema_fragments',
            //   );
            // }, 100000);
        });
        describe('get calls', () => {
            const runGetCallTest = (createMethod, sdkCustomizationGetMethod, deleteMethod, objectType, customKey) => __awaiter(void 0, void 0, void 0, function* () {
                const createRequestParams = yield getCreateRequestParameters(createMethod);
                const wantObject = (yield createMethod(Object.assign(Object.assign({}, createRequestParams), { [customKey]: fragmentIDs }))).data[`${objectType}`];
                expect(wantObject).toEqual(expect.objectContaining({ custom_schema_fragments: fragmentIDs }));
                // Calling the SDK method
                const haveObject = (yield sdkCustomizationGetMethod({ id: wantObject.id })).data[`${objectType}`];
                expect(haveObject).toEqual(expect.objectContaining({ custom_schema_fragments: fragmentIDs }));
                for (let i = 0; i < fragmentIDs.length; ++i) {
                    const fragmentID = fragmentIDs[i];
                    const wantFragment = fragmentIDToSchemaMap.get(fragmentID);
                    const haveFragment = haveObject === null || haveObject === void 0 ? void 0 : haveObject.custom_fragment[i]; // Preserves the order of the fragments
                    expect(haveFragment).toEqual(wantFragment);
                }
                // Cleanup
                if (deleteMethod) {
                    yield deleteMethod({ id: wantObject.id });
                }
            });
            test('return custom_fragment for works.get', () => __awaiter(void 0, void 0, void 0, function* () {
                yield runGetCallTest(workflow.worksCreate, workflow.worksGetWithCustomFragments.bind(workflow), workflow.worksDelete, 'work', 'custom_schema_fragments');
            }), 100000);
            test('return custom_fragment for accounts.get', () => __awaiter(void 0, void 0, void 0, function* () {
                yield runGetCallTest(workflow.accountsCreate, workflow.accountsGetWithCustomFragments.bind(workflow), workflow.accountsDelete, 'account', 'schema_fragment_ids');
            }), 100000);
            // Clean-up is not supported. It will be supported when account fields are added to RevOrg APIs in beta.
            // Note: Uncomment the code adding account ID in revOrgs create request parameters.
            test('return custom_fragment for rev-orgs.get', () => __awaiter(void 0, void 0, void 0, function* () {
                yield runGetCallTest(workflow.revOrgsCreate, workflow.revOrgsGetWithCustomFragments.bind(workflow), null, 'rev_org', 'custom_schema_fragments');
            }), 100000);
            // Clean-up is not supported. It will be supported when rev_org fields are added to RevUser APIs in beta.
            // Note: Uncomment the code adding rev_org ID in revUsers create request parameters.
            test('return custom_fragment for rev-users.get', () => __awaiter(void 0, void 0, void 0, function* () {
                yield runGetCallTest(workflow.revUsersCreate, workflow.revUsersGetWithCustomFragments.bind(workflow), workflow.revUsersDelete, 'rev_user', 'custom_schema_fragments');
            }), 100000);
            // TODO: This test is not working because of absence of custom_schema_fragments in the request of parts.create API.
            // Update public-beta-devrev-sdk.ts to add custom_schema_fragments in the request of parts.create API.
            // test('return custom_fragment for parts.get', async () => {
            //   await runGetCallTest(
            //     workflow.partsCreate,
            //     workflow.partsGetWithCustomFragments.bind(workflow),
            //     workflow.partsDelete,
            //     'part',
            //     'schema_fragment_ids',
            //   );
            // }, 100000);
        });
    });
});
//# sourceMappingURL=workflow.test.js.map